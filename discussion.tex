\section{Discussion and Implications}
\label{sec:discussion}

% [Lessons learned and suggestions for future work.]

All of the existing techniques we have analyzed cannot fully automate the process of the decomposition of a monolithic system into a microservice system. Both \fs and \bn provide a guideline of a potential approach of splitting the system, but these techniques do not modify nor generate code. Human efforts are still required to complete the process of decomposition by gluing each module (class) within each microservice by using proper frameworks and adding additional service for communication between services. The remaining work for the migration is still quite a lot, especially when the system scale is large. 

The effort of transform or extract from the source code of the monolithic system into technique-specific data form cannot be neglected. \fs's results highly depend on the quality and coverage of the tracings. [elaborate on this.] \bn requires Module Dependency Graph, which needs to be generated using other tools. Neither of these techniques allows developers to simply put the whole system as the input. Therefore, these techniques are useful to developers only when the software size is relatively large so that ideally, it would be less time on producing inputs to these techniques than the time needed for analyzing the software manually. 

Both techniques we have selected for this analysis use heuristic algorithms to find the best extraction, and as such, does not guarantee to produce the same result in multiple runs. Although these algorithms often produce a family of similar results, it is difficult for humans to interpret the differences and conclude the best one among them.

As part of our on-going work, we are studying on analyzing the performance of using the existing techniques on larger-scale applications to mitigate the bias of analyzing only small scale software systems. Large-scale benchmarks have a higher tolerance for the noises in the results, and therefore, the MoJoFM value can better represent the actual similarity between the two architectures. 

In this comparative analysis, we have only selected two extraction techniques to represent static and dynamic tools, respectively. Besides \fs and \bn, there still exists a reasonable amount of techniques that can potentially be used for software system decomposition. One of the promising technique is called ACDC, which observes specific patterns for grouping implementation-level entities recur. These patterns can be then used for clustering the software. Unfortunately, the tool does not apply to the three benchmarks since it requires the system to have at least 100 entities to be able to observe enough patterns for clustering. Once we find a suitable large-scale software system, we can perform experiments on it using ACDC.

For the future study on developing the extraction tools, how to categorize the "common" classes should be one of the primary concerns. "Common" classes refer to the classes that serve for a general-purpose across multiple services, including utility and exception classes. These classes should either be duplicated throughout their usage or separate as an individual service. Grouping these classes with any other service violates the architecture of microservice design. 

In addition, static analysis aided approaches often ignore the framework the applications rely on. The framework usually implies indirect relationships between modules of the application, and fail to detect such relationships produces insufficient inputs to the extraction techniques such that the accuracy of the results is negatively affected. Future study on static analysis aided approaches needs to take the framework as one of the essential considerations to be able to achieve higher accuracy.  